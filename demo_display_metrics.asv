clear all; close all; clc; rng(0);

%% parameters
M_name = 'tr_reg_023';

n_points = 1000;    % number of vertices used to build PC-Gau (q)
sigma = 0.05;       % amplitude of the gaussians used to build PC-Gau (sigma)
k = 60;             % number of atoms to consider

egdc_param = 80;            % sets the scale for the egdc metric
mgd_param = 10;             % sets the scale for the mgd metric

%% load meshes and compute LB basis
M = mesh.load_faust(M_name);

%% compute PC-Gau
para.n_atoms = 200;
M.our_basis = compute_PC_Gau(M, n_points, sigma, true, para);

%% embeddings
% embeddings with delta functions are the basis matrices transposed
embeddings_ours = M.our_basis(:,1:k)';
embeddings_LB = M.Phi(:,1:k)';

% For each vertex, compute the nearest embedding and its embedding distance
[min_dist_ours, ours_nn] = compute_min_dist(embeddings_ours);    
[min_dist_LB, LB_nn] = compute_min_dist(embeddings_LB);   

% initialize vectors to contain metric values
Dis_ours = zeros(M.n, 1);
Dis_LB = zeros(M.n, 1);
EGDC_ours = zeros(M.n, 1);
EGDC_LB = zeros(M.n, 1);
MGD_ours = zeros(M.n, 1);
MGD_LB = zeros(M.n, 1);
        
%% Discrimination power (Dis)
disp('computing metrics, it may take a while...');
for point = 1:M.n
    % geodesic distances from the current point
    geodesic_distances = distances(M.norm_G, point)';  
    % embedding distances from the current point, for ours and LB
    emb_dist_ours = pdist2(embeddings_ours(:,point)', embeddings_ours')';
    emb_dist_LB = pdist2(embeddings_LB(:,point)', embeddings_LB')';
    
    % Set the metrics' values in the current point
    
    % Discrimination power: distance from the nearest embedding normalized
    % by the geodesic distance of the corresponding vert
    Dis_ours(point) = min_dist_ours(point) / geodesic_distances(ours_nn(point));
    Dis_LB(point) = min_dist_LB(point) / geodesic_distances(LB_nn(point));
    
    % EGDC
    EGDC_ours(point) = compute_egdc(geodesic_distances, emb_dist_ours, egdc_param);
    EGDC_LB(point) = compute_egdc(geodesic_distances, emb_dist_LB, egdc_param);
    
    % MGD
    MGD_ours(point) = compute_mgd(geodesic_distances, emb_dist_ours, mgd_param);
    MGD_LB(point) = compute_mgd(geodesic_distances, emb_dist_LB, mgd_param);   
end

%% figure parameters
viz_params.x = 83;
viz_params.y = 0;
viz_params.z = -10;
viz_params.view = [-37.5 10];
viz_params.diffuseStrength = 0.5;

%% Plot Dis
fig = figure('position', [100 100 900 900]);
tlo = tiledlayout(1,2);
lim_inf = min([Dis_ours; Dis_LB]);
lim_sup = max([Dis_ours; Dis_LB])*0.5;      % rescaled for better visualization

nexttile(); utils.plot_scalar_map_2(M, Dis_ours, hot, viz_params);
caxis([lim_inf, lim_sup]); 
title(['Dis (ours), mean: ', num2str(mean(Dis_ours), '%.1f')]);

nexttile(); utils.plot_scalar_map_2(M, Dis_LB, hot, viz_params);
caxis([lim_inf, lim_sup]); 
colorbar;
title(['Dis (LB), mean: ', num2str(mean(Dis_LB), '%.1f')]);

title(tlo, 'Discrimination power', 'fontSize', 24)
subtitle(tlo, 'Lower (darker) is worse', 'fontSize', 18)


%% Plot EGDC
fig = figure('position', [100 100 900 900]);
tlo = tiledlayout(1,2);
lim_inf = min([EGDC_ours; EGDC_LB]);
lim_sup = max([EGDC_ours; EGDC_LB]);

nexttile(); utils.plot_scalar_map_2(M, EGDC_ours, hot, viz_params);
caxis([lim_inf, lim_sup]); 
title(['EGDC (ours), mean: ', num2str(mean(EGDC_ours), '%.3f')]);

nexttile(); utils.plot_scalar_map_2(M, EGDC_LB, hot, viz_params);
caxis([lim_inf, lim_sup]); 
colorbar;
title(['EGDC (LB), mean: ', num2str(mean(EGDC_LB), '%.3f')]);

title(tlo, 'Embedding/Geodeisc distance correlation', 'fontSize', 24)
subtitle(tlo, 'Lower (darker) is worse', 'fontSize', 18)

%% Plot MGD
fig = figure('position', [100 100 900 900]);
tlo = tiledlayout(1,2);
lim_inf = min([MGD_ours; MGD_LB]);
lim_sup = max([MGD_ours; MGD_LB])*0.5;      %rescaled for better visualization

nexttile(); utils.plot_scalar_map_2(M, MGD_ours, flipud(hot), viz_params);
caxis([lim_inf, lim_sup]); 
title(['MGD (ours), mean: ', num2str(mean(MGD_ours), '%.2f')]);

nexttile(); utils.plot_scalar_map_2(M, MGD_LB, flipud(hot), viz_params);
caxis([lim_inf, lim_sup]); 
colorbar;
title(['MGD (LB), mean: ', num2str(mean(MGD_LB), '%.2f')]);

title(tlo, 'Mean Geodesic Distance (normalized)', 'fontSize', 24)
subtitle(tlo, 'Higher (darker) is worse', 'fontSize', 18)



%%
function egdc = compute_egdc(geodesic_distances, spectral_distances, s)
    [sorted_spectral, idxs] = sort(spectral_distances);
    sorted_geodesic = geodesic_distances(idxs);
    egdc = corr(sorted_spectral(1:s), sorted_geodesic(1:s));

end

function mgd_norm = compute_mgd(geodesic_distances, spectral_distances, t)
    [~, idxs] = sort(spectral_distances);
    sorted_geodesic = geodesic_distances(idxs);
    real_geo_dist = mink(geodesic_distances, t);
    mgd = mean(sorted_geodesic(1:t));
    mgd_norm = mgd ./ mean(real_geo_dist);
end

function [min_dist, nn] = compute_min_dist(embeddings)
    [nn,min_dist] = knnsearch(embeddings', embeddings', 'K', 2);
    min_dist = min_dist(:,2);
    nn = nn(:,2);
end
